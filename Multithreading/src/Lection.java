
public class Lection {
	
	/*
	 * one Object can hold only one lock
	 * if Thread-1 accessed Lock for Object1
	 * Thread-2 cannot access Lock for Object2 
	 * 
	main - метод, который запускает основной поток
	остальные потоки могут создаваться в методе main
	у всех потоков одна память
	процесс - дорогостоящая операция
	
	процесс выполняется, пока хоть один поток его выполняет
	
	псевдо - параллелизм это симмуляция многопоточности
	в одноядерной системе
	
	в Java создаются потоки в JVM
	Thread Scheduler уже распределяет как созданные потоки ложатся на 
	потоки потоки ОС
	
	Существуют потоки - демоны
	Они имеют низкий приоритет
	Он завершается при заавершении всего приложения
	
	Есть приоритет потока
	от 1 до 10
	Это значит, что планировщик больше дает роботу
	потоку с высоким приоритетом
	
	10 - максимум
	1 - минимум
	
	5 - default значение
	
	создание потока двумя путями
	extends Thread   	или 		implements Runnable
	создание потока лучше от interface Runnable
	из-за инкапсулции задачи отдельной и
	множественного наследования от интерфейса Runnable
	
	класс Thread имеет метод run()
	он по умолячанию пустой
	
	новый поток запускается методом start()
	
	метод interrupt останавливает поток
	но когда он остановится, решает Thread Scheduler 
	
	метод join(long millisec) - если первый поток
	вызывает метод join() у второго потока, то первый
	будет заблокирован до тех пока пока второй поток не
	завершит свою работу, или на установленное время в
	миллисекундах
	
	есть потоки t1, main
	t1.join(50000);
	поток t1 выполняется,
	а main ждёт конца выполнения t1
	
	если поток бросает Exception, то все потоки падают
	
	Exception нужно ловить в методе run() каждого метода
	
	можно синхронизировать методы или целые секции кода
	private void synchronized set() {}
	synchronized
	(this)
	
	синхронизирванныый метод "легче" по памяти, чем
	синхронизированный блок
	
	synchorinized метод гарантирует, что один метод
	не будет выполняться несколькими потоками
	а только одним
	но у каждого потока свой стек
	
	а volatile помещает переменную в общую память
	
	чтение и запись - атомарные операции
	тоесть выполняется за один раз,
	кроме как чтение и запись double, long
	избежать этого можно добавляю ключевое слово volatile
	
	private volatile long value
	
	wait-notify сделан потому, что
	synchronized метод ставит флаг блокировки на объект
	и его обрабатывает один поток
	а остальные потоки отправляют ping объекту
	спрашивая "мы уже приехали? мы уже приехали? а сейчас?"
	это занимает место
	
	wait()-notify() помогает это исправить
	wait() помогает не кушать ресурсы потоку, который бы ping'овал
	когда флаг блокировки снят, то notify() уведомит поток
	что объект свободен
	
	notifyAll() уведомляет все потоки, что флаг свободен
	
	*/
}
